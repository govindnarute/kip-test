{"version":3,"sources":["../../../src/services/files/ImagesService.js"],"names":["ImagesService","constructor","config","DBConnection","Image","model","UsersImage","checkUploadedImageForUse","request","response","next","image","scope","method","ImageStatus","Loaded","findByPk","body","imageId","NotFoundError","authorId","user","userId","ForbiddenError","addAvatar","userImages","update","create","createImage","resFetch","Promise","resolve","mime","headers","get","mimetype","split","newFileName","uuid","v4","createStream","fs","createWriteStream","__dirname","pipe","on","path","name","createImageInDb","getImageById"],"mappings":";;;;;;AAAA;;;;AACA;;;;AACA;;;;AAEA;;AACA;;;;AAEe,MAAMA,aAAN,CAAoB;AAC/BC,gBAAY,EAAEC,MAAF,EAAUC,YAAV,EAAZ,EAAsC;AAClC,aAAKD,MAAL,GAAcA,MAAd;AACA,aAAKE,KAAL,GAAaD,aAAaE,KAAb,CAAmB,OAAnB,CAAb;AACA,aAAKC,UAAL,GAAkBH,aAAaE,KAAb,CAAmB,YAAnB,CAAlB;AACH;;AAED;;;;;;;AAOA,UAAME,wBAAN,CAA+BC,OAA/B,EAAwCC,QAAxC,EAAkDC,IAAlD,EAAwD;AACpD,cAAMC,QAAQ,MAAM,KAAKP,KAAL,CACfQ,KADe,CACT,EAAEC,QAAQ,CAAC,UAAD,EAAaC,oBAAYC,MAAzB,CAAV,EADS,EAEfC,QAFe,CAENR,QAAQS,IAAR,CAAaC,OAFP,CAApB;;AAIA,YAAI,CAACP,KAAL,EAAY;AACR,mBAAOD,KAAK,IAAIS,mBAAJ,CAAkB,iBAAlB,CAAL,CAAP;AACH;;AAED,YAAIR,SAASA,MAAMS,QAAN,KAAmBZ,QAAQa,IAAR,CAAaC,MAA7C,EAAqD;AACjD,mBAAOZ,KAAK,IAAIa,oBAAJ,CAAmB,yBAAnB,CAAL,CAAP;AACH;AACDb;AACH;;AAED;;;;;;;AAOA,UAAMc,SAAN,CAAgBC,UAAhB,EAA4BP,OAA5B,EAAqCI,MAArC,EAA6C;AACzC,YAAIG,UAAJ,EAAgB;AACZ,kBAAMA,WAAWC,MAAX,CAAkB,EAAER,OAAF,EAAlB,CAAN;AACA;AACH;;AAED,cAAM,KAAKZ,UAAL,CAAgBqB,MAAhB,CAAuB;AACzBL,kBADyB;AAEzBJ;AAFyB,SAAvB,CAAN;AAIH;;AAED,UAAMU,WAAN,CAAkBC,QAAlB,EAA4B;AACxB,eAAO,IAAIC,OAAJ,CAAaC,OAAD,IAAa;AAC5B,kBAAMC,OAAOH,SAASI,OAAT,CAAiBC,GAAjB,CAAqB,cAArB,CAAb;AACA,kBAAMC,WAAWH,KAAKI,KAAL,CAAW,GAAX,EAAgB,CAAhB,CAAjB;AACA,kBAAMC,cAAe,GAAE,KAAKnC,MAAL,CAAYgC,GAAZ,CAAgB,gBAAhB,CAAkC,GAAEI,eAAKC,EAAL,EAAU,EAArE;AACA,kBAAMC,eAAeC,aAAGC,iBAAH,CAAqBC,YAAa,kBAAiBN,WAAY,IAAGF,QAAS,EAA3E,CAArB;AACAN,qBAASZ,IAAT,CAAc2B,IAAd,CAAmBJ,YAAnB;AACAA,yBAAaK,EAAb,CAAgB,OAAhB,EAAyB,MAAM;AAC3Bd,wBAAQ;AACJe,0BAAMA,eAAKf,OAAL,CAAaY,SAAb,EAAyB,kBAAiBN,WAAY,IAAGF,QAAS,EAAlE,CADF;AAEJH,wBAFI;AAGJe,0BAAO,GAAEV,WAAY,IAAGF,QAAS;AAH7B,iBAAR;AAKH,aAND;AAOH,SAbM,CAAP;AAcH;;AAED;;;;;;AAMA,UAAMa,eAAN,CAAsB5B,QAAtB,EAAgC2B,IAAhC,EAAsC;AAClC,eAAO,KAAK3C,KAAL,CAAWuB,MAAX,CAAkB;AACrBP,oBADqB;AAErB2B;AAFqB,SAAlB,CAAP;AAIH;;AAED;;;;;AAKA,UAAME,YAAN,CAAmB/B,OAAnB,EAA4B;AACxB,eAAO,KAAKd,KAAL,CAAWY,QAAX,CAAoBE,OAApB,CAAP;AACH;;AArF8B;kBAAdlB,a","file":"ImagesService.js","sourcesContent":["import uuid from 'uuid';\nimport fs from 'fs';\nimport path from 'path';\n\nimport { NotFoundError, ForbiddenError } from '../../utils/http';\nimport { ImageStatus } from '../../resources/images';\n\nexport default class ImagesService {\n    constructor({ config, DBConnection }) {\n        this.config = config;\n        this.Image = DBConnection.model('Image');\n        this.UsersImage = DBConnection.model('UsersImage');\n    }\n\n    /**\n     * Check image creator\n     * @param request\n     * @param response\n     * @param next\n     * @returns {function(*, *, *)}\n     */\n    async checkUploadedImageForUse(request, response, next) {\n        const image = await this.Image\n            .scope({ method: ['byStatus', ImageStatus.Loaded] })\n            .findByPk(request.body.imageId);\n\n        if (!image) {\n            return next(new NotFoundError('IMAGE_NOT_FOUND'));\n        }\n\n        if (image && image.authorId !== request.user.userId) {\n            return next(new ForbiddenError('WITHOUT_ACCESS_TO_IMAGE'));\n        }\n        next();\n    }\n\n    /**\n     * Add avatar to user\n     * @param {array} userImages\n     * @param {number} imageId\n     * @param {number} userId\n     * @returns {Promise.<void>}\n     */\n    async addAvatar(userImages, imageId, userId) {\n        if (userImages) {\n            await userImages.update({ imageId });\n            return;\n        }\n\n        await this.UsersImage.create({\n            userId,\n            imageId\n        });\n    }\n\n    async createImage(resFetch) {\n        return new Promise((resolve) => {\n            const mime = resFetch.headers.get('content-type');\n            const mimetype = mime.split('/')[1];\n            const newFileName = `${this.config.get('s3.imagePrefix')}${uuid.v4()}`;\n            const createStream = fs.createWriteStream(__dirname + `/../../../temp/${newFileName}.${mimetype}`);\n            resFetch.body.pipe(createStream);\n            createStream.on('close', () => {\n                resolve({\n                    path: path.resolve(__dirname, `/../../../temp/${newFileName}.${mimetype}`),\n                    mime,\n                    name: `${newFileName}.${mimetype}`\n                });\n            });\n        });\n    }\n\n    /**\n     * Create image in DB\n     * @param authorId\n     * @param name\n     * @returns {Promise.<void>}\n     */\n    async createImageInDb(authorId, name) {\n        return this.Image.create({\n            authorId,\n            name\n        });\n    }\n\n    /**\n     * Get image by id\n     * @param imageId\n     * @returns {Promise.<Promise.<Model>|Bluebird<any | TInstance>>}\n     */\n    async getImageById(imageId) {\n        return this.Image.findByPk(imageId);\n    }\n\n}\n"]}