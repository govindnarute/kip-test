{"version":3,"sources":["../../../src/services/users/UsersService.js"],"names":["UsersService","constructor","DBConnection","dbConnection","User","model","UserCompensations","UserAvailability","getProviders","query","userId","providers","replacements","offset","limit","fromMySchool","fromMyGroup","minExp","identities","hasLocations","locationsId","length","hasIndustries","industriesId","hasFunctions","functionsId","keyword","type","QueryTypes","SELECT","count","totalCount","resultProviders","getProvidersWithoutPagination","scopes","scope","findAll","setScopesAndGetProviders","withoutPagination","list","listData","rows","checkProfileCompleted","request","response","next","hasCompletedProfile","user","ForbiddenError","checkUserVerification","findByPk","NotFoundError","checkUserForRefresh","UnprocessableError","getCount","getUserById","concat","updatesUserById","updateData","update","where","id","getUserByEmail","email","findOne","createUser","body","Object","assign","save","getUserByEmailWithVerificationToken","method","push","getUserCompensations","saveUserCompensations","data","getUserAvailability","saveUserAvailability","checkUserIdentities","mask","MaskHelper","parseMaskToFlags","isProfessional","isCoach"],"mappings":"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","file":"UsersService.js","sourcesContent":["import {\n    NotFoundError,\n    UnprocessableError,\n    ForbiddenError\n} from '../../utils/http';\nimport { MaskHelper } from '../../helpers/MaskHelper';\n\nexport default class UsersService {\n    constructor({ DBConnection }) {\n        this.dbConnection = DBConnection;\n        this.User = DBConnection.model('User');\n        this.UserCompensations = DBConnection.model('UserCompensations');\n        this.UserAvailability = DBConnection.model('UserAvailability');\n    }\n\n    /**\n     * Get providers (seeker-providers)\n     * @param query\n     * @param userId\n     * @returns {Promise.<*>}\n     */\n    async getProviders(query, userId) {\n        const providers = await this.dbConnection.query(\n            `\n    SELECT SQL_CALC_FOUND_ROWS\n    users.id,\n    users.firstName,\n    users.lastName,\n    users.email,\n    (\n      SELECT images.name FROM usersImages\n      INNER JOIN images ON images.id = usersImages.imageId\n      WHERE usersImages.userId = users.id LIMIT 1\n    ) as avatar,\n    (\n      SELECT JSON_ARRAYAGG(f.name) FROM userProfessionals AS p\n      LEFT JOIN professionalIndustries AS pf ON pf.userProfessionalId = p.id\n      LEFT JOIN industries AS f ON pf.industryId = f.id\n      WHERE p.userId = users.id\n      ORDER BY f.name\n    ) as industries,\n    users.headline,\n    users.summary,\n    locations.name AS location\n    FROM users\n    INNER JOIN userAvailability AS availability ON availability.userId = users.id\n    INNER JOIN userCompensations AS compensation ON compensation.userId = users.id\n    LEFT JOIN locations ON locations.id = users.id\n    LEFT JOIN userProfessionals AS professionals ON professionals.userId = users.id\n    LEFT JOIN userCoaches AS coaches ON coaches.userId = users.id\n    LEFT JOIN professionalFunctions ON professionalFunctions.userProfessionalId = professionals.id\n    LEFT JOIN professionalIndustries ON professionalIndustries.userProfessionalId = professionals.id\n    LEFT JOIN industries ON industries.id = professionalIndustries.industryId\n    WHERE users.id != :userId AND type IN (2, 3) -- exclude self, include only 2 - provider, 3 - both\n    -- Prefilter #1\n    AND isKnowledgeProviderAvailable(users.id)\n    -- Prefilter #2\n    AND (\n        CASE availability.availableFor\n        -- everyone\n        WHEN 1 THEN TRUE\n        -- students\n        WHEN 2 THEN (SELECT identities & 0b11 != 0 FROM users WHERE id = :userId)\n        -- professionals\n        WHEN 3 THEN (SELECT identities & 0b1100 != 0 FROM users WHERE id = :userId)\n        -- fromMySchool\n        WHEN 4 THEN haveCommonSchools(:userId, users.id)\n        ELSE FALSE\n        END\n    )\n    -- Prefilter #3\n    -- AND hasCompletedProfile(users.id)\n    \n    -- #1 Keyword\n    AND (\n        :keyword IS NULL\n        OR users.firstName LIKE :keyword\n        OR users.lastName LIKE :keyword\n        OR CONCAT(users.firstName, ' ', users.lastName) LIKE :keyword\n        OR users.headline LIKE :keyword\n        OR users.summary LIKE :keyword\n        OR users.headline LIKE :keyword\n        OR compensation.notes LIKE :keyword\n        OR (SELECT EXISTS(SELECT 1 FROM functions WHERE id = professionalFunctions.functionId AND name LIKE :keyword))\n        OR (SELECT EXISTS(SELECT 1 FROM industries WHERE id = professionalIndustries.industryId AND name LIKE :keyword))\n    )\n    \n    -- #2 Identity\n    AND (:identities IS NULL OR -- both \n        CASE :identities\n        -- professors\n        WHEN 1 THEN (SELECT 1 WHERE identities IN (4,5,6,7,12,13,14,15))\n        -- coach\n        WHEN 2 THEN (SELECT 1 WHERE identities IN (8,9,10,11,12,13,14,15))\n        -- both \n        WHEN 3 THEN (SELECT 1 WHERE identities IN (4,5,6,7,8,9,10,11,12,13,14,15))\n        END\n    )\n    \n    -- #3 Industry\n    AND (NOT :hasIndustries OR professionalIndustries.industryId IN (:industriesId))\n    \n    -- #4 Function\n    AND (NOT :hasFunctions OR professionalFunctions.functionId IN (:functionsId))\n    \n\n    -- #5 Location\n    AND (NOT :hasLocations OR locationId IN (:locationsId))\n    \n    -- #6 Min yrs of experience\n    AND (:minExp IS NULL OR professionals.yearOfExperience >= :minExp OR coaches.yearOfExperience >= :minExp)\n    \n    -- #7 From my schools\n    AND (:fromMySchool IS NULL OR NOT :fromMySchool OR haveCommonSchools(:userId, users.id))\n\n    -- #8 In my groups?\n    AND (:fromMyGroup IS NULL OR NOT :fromMyGroup OR haveCommonGroups(:userId, users.id))\n\n    GROUP BY users.id\n\n    LIMIT :offset, :limit;\n`,\n            {\n                replacements: {\n                    userId: userId,\n                    offset: query.offset,\n                    limit: query.limit,\n                    fromMySchool: query.fromMySchool || false,\n                    fromMyGroup: query.fromMyGroup || null,\n                    minExp: query.minExp || null,\n                    identities: query.identities || null,\n                    hasLocations:\n                        (query.locationsId && query.locationsId.length) ||\n                        false,\n                    locationsId: query.locationsId || [-1],\n                    hasIndustries:\n                        (query.industriesId && query.industriesId.length) ||\n                        false,\n                    industriesId: query.industriesId || [-1],\n                    hasFunctions:\n                        (query.functionsId && query.functionsId.length) ||\n                        false,\n                    functionsId: query.functionsId || [-1],\n                    keyword: query.keyword ? '%' + query.keyword + '%' : null\n                },\n                type: this.dbConnection.QueryTypes.SELECT\n            }\n        );\n\n        const count = await this.dbConnection.query('SELECT FOUND_ROWS();', {\n            type: this.dbConnection.QueryTypes.SELECT\n        });\n\n        const totalCount = count[0]['FOUND_ROWS()'];\n\n        const resultProviders = { providers, totalCount };\n\n        return resultProviders;\n    }\n\n    /**\n     * Get providers without pagination\n     * @param scopes\n     * @returns {Promise.<*>}\n     */\n    async getProvidersWithoutPagination(scopes) {\n        return await this.User.scope(scopes).findAll();\n    }\n\n    /**\n     * Set scopes and get providers\n     * @param query\n     * @param userId\n     * @returns {Promise.<*>}\n     */\n    async setScopesAndGetProviders(query, userId, withoutPagination = false) {\n        let list = [];\n        let listData = {};\n        const scopes = [];\n        let count;\n\n        if (withoutPagination) {\n            list = await this.getProvidersWithoutPagination(scopes);\n        } else {\n            listData = await this.getProviders(scopes, query, userId);\n            list = listData.rows;\n            count = listData.count;\n        }\n\n        return { list, count };\n    }\n\n    /**\n     * Check user availability to dashboard\n     * @param request\n     * @param response\n     * @param next\n     * @returns {Promise.<*>}\n     */\n    async checkProfileCompleted(request, response, next) {\n        const hasCompletedProfile = await this.dbConnection.query(\n            'SELECT hasCompletedProfile(:userId)',\n            {\n                replacements: { userId: request.user.userId },\n                type: this.dbConnection.QueryTypes.SELECT\n            }\n        );\n\n        if (\n            !hasCompletedProfile[0][\n                `hasCompletedProfile(${request.user.userId})`\n            ]\n        ) {\n            return next(new ForbiddenError('ACCESS_DENIED'));\n        }\n\n        next();\n    }\n\n    /**\n     * Check user verification\n     * @param request\n     * @param response\n     * @param next\n     * @returns {Promise.<*>}\n     */\n    async checkUserVerification(request, response, next) {\n        const user = await this.User.findByPk(request.user.userId);\n\n        if (!user) {\n            return next(new NotFoundError('USER_NOT_FOUND'));\n        }\n\n        next();\n    }\n\n    /**\n     * Check user for refresh\n     * @param userId\n     * @returns {Promise.<void>}\n     */\n    async checkUserForRefresh(userId) {\n        const user = await this.User.findByPk(userId);\n\n        if (!user) {\n            throw new UnprocessableError('USER_NOT_FOUND');\n        }\n    }\n\n    /**\n     * Get count\n     * @param scopes\n     * @returns {Promise.<void>}\n     */\n    async getCount(scopes) {\n        return this.User.scope(scopes).count();\n    }\n\n    /**\n     * Get user by id\n     * @param userId\n     * @param scope\n     * @returns {Promise.<Promise.<Model>|Bluebird<any | TInstance>>}\n     */\n    async getUserById(userId, scope = []) {\n        return this.User.scope(scope.concat('withAvatar')).findByPk(userId);\n    }\n\n    /**\n     * Update user by id\n     * @param userId\n     * @param updateData\n     * @param scope\n     * @returns {Promise.<Promise.<Model>|Bluebird<any | TInstance>>}\n     */\n    async updatesUserById(userId, updateData) {\n        return this.User.update(updateData, { where: { id: userId } });\n    }\n\n    /**\n     * Get user by email\n     * @param email\n     * @param scope\n     * @returns {Promise.<Promise.<Model>|Bluebird<any | TInstance>>}\n     */\n    async getUserByEmail(email, scope = []) {\n        return this.User.scope(scope.concat('withAvatar')).findOne({\n            where: { email }\n        });\n    }\n\n    /**\n     * Create user\n     * @param body\n     * @returns {Promise.<user>}\n     */\n    async createUser(body) {\n        return new this.User(Object.assign({}, body)).save();\n    }\n\n    /**\n     * Get user by email and verification token\n     * @param email\n     * @param type\n     * @param scope\n     * @returns {Promise.<Promise.<Model>|Bluebird<any | TInstance>>}\n     */\n    async getUserByEmailWithVerificationToken(email, type, scope = []) {\n        const scopes = [{ method: ['withTokenByType', type] }];\n        scopes.push(scope);\n\n        return this.User.scope(scopes).findOne({ where: { email } });\n    }\n\n    /**\n     * Get user compensation\n     * @param userId\n     * @returns {Promise.<Promise>}\n     */\n    async getUserCompensations(userId) {\n        return this.UserCompensations.findOne({ where: { userId } });\n    }\n\n    /**\n     * Create user compensation\n     * @param data\n     * @returns {Promise.<Promise>}\n     */\n    async saveUserCompensations(data) {\n        return new this.UserCompensations(Object.assign({}, data)).save();\n    }\n\n    async getUserAvailability(userId) {\n        return this.UserAvailability.findOne({ where: { userId } });\n    }\n\n    /**\n     * Create user availability\n     * @param data\n     * @returns {Promise.<Promise>}\n     */\n    async saveUserAvailability(data) {\n        return new this.UserAvailability(Object.assign({}, data)).save();\n    }\n\n    /**\n     * Check user identities\n     * @param request\n     * @param response\n     * @param next\n     * @returns {Promise.<*>}\n     */\n    async checkUserIdentities(request, response, next) {\n        const user = await this.User.findByPk(request.user.userId);\n        const mask = MaskHelper.parseMaskToFlags(user.identities);\n\n        if (!mask.isProfessional && !mask.isCoach) {\n            return next(new ForbiddenError('IDENTITY_ERROR'));\n        }\n\n        next();\n    }\n}\n"]}