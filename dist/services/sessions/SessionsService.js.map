{"version":3,"sources":["../../../src/services/sessions/SessionsService.js"],"names":["SessionsService","getUserAppendix","userId","ObjectKeyComposer","createKey","getSessionAppendix","constructor","RedisWrapper","config","UsersService","redisClient","usersService","destroyAllSessions","sessionKey","existAccessTokens","lrange","forEach","token","del","keys","concat","toString","create","sessionOptions","type","SessionType","User","role","undefined","uniqueKey","uuid","v4","tokenParams","sessionId","lifeTime","get","accessToken","JWT","sign","data","expiresIn","addTokenToSessionList","set","JSON","stringify","tokenType","refreshToken","lpush","deleteTokenFromSessionList","lrem","findSession","cachedSession","parse","destroy","adminId","refresh","sessionParams","verifyToken","checkUserForRefresh","verify","e","UnprocessableError"],"mappings":";;;;;;AAAA;;;;AACA;;;;AAEA;;AACA;;AACA;;;;AACA;;;;;;AAMA;;;;;;;AAOA;;;;;;;;;AASe,MAAMA,eAAN,CAAsB;;AAEjC;;;;AAIA,WAAOC,eAAP,CAAuBC,MAAvB,EAA+B;AAC3B,eAAOC,qCAAkBC,SAAlB,CAA4B,MAA5B,EAAoCF,MAApC,CAAP;AACH;;AAED;;;;AAIA,WAAOG,kBAAP,CAA0BH,MAA1B,EAAkC;AAC9B,eAAOC,qCAAkBC,SAAlB,CAA4B,cAA5B,EAA4CF,MAA5C,CAAP;AACH;;AAED;;;AAGAI,gBAAY,EAAEC,YAAF,EAAgBC,MAAhB,EAAwBC,YAAxB,EAAZ,EAAoD;AAChD;;;;AAIA,aAAKC,WAAL,GAAmBH,YAAnB;;AAEA;;;;AAIA,aAAKC,MAAL,GAAcA,MAAd;;AAEA,aAAKG,YAAL,GAAoBF,YAApB;AACH;;AAED;;;;AAIA,UAAMG,kBAAN,CAAyBV,MAAzB,EAAiC;AAC7B,cAAMW,aAAab,gBAAgBK,kBAAhB,CAAmCH,MAAnC,CAAnB;AACA,cAAMY,oBAAoB,MAAM,KAAKJ,WAAL,CAAiBK,MAAjB,CAAwBF,UAAxB,EAAoC,CAApC,EAAuC,CAAC,CAAxC,CAAhC;AACAC,0BAAkBE,OAAlB,CAA2BC,SAAS,KAAKP,WAAL,CAAiBQ,GAAjB,CAAqBD,KAArB,CAApC;AACA,cAAME,OAAOL,kBAAkBM,MAAlB,CAAyBP,UAAzB,CAAb;AACA,cAAM,KAAKH,WAAL,CAAiBQ,GAAjB,CAAqBC,KAAKE,QAAL,EAArB,CAAN;AACH;;AAED;;;;;AAKA,UAAMC,MAAN,CAAapB,MAAb,EAAqBqB,iBAAiB,EAAEC,MAAMC,yBAAYC,IAApB,EAA0BC,MAAMC,SAAhC,EAAtC,EAAmF;AAC/E,cAAMC,YAAYC,eAAKC,EAAL,EAAlB;;AAEA;;;AAGA,cAAMC,cAAc;AAChB9B,kBADgB;AAEhBsB,kBAAMD,eAAeC,IAFL;AAGhBG,kBAAMJ,eAAeI,IAHL;AAIhBM,uBAAWJ;AAJK,SAApB;;AAOA,cAAMK,WAAWX,eAAeW,QAAf,IAA2B,KAAK1B,MAAL,CAAY2B,GAAZ,CAAgB,cAAhB,CAA5C;;AAEA,cAAMC,cAAcC,uBAAIC,IAAJ,CAAS;AACzBC,kBAAMP;AADmB,SAAT,EAEjB,KAAKxB,MAAL,CAAY2B,GAAZ,CAAgB,SAAhB,CAFiB,EAEW;AAC3BK,uBAAWN;AADgB,SAFX,CAApB;;AAMA,cAAM,KAAKO,qBAAL,CAA2BvC,MAA3B,EAAmCkC,WAAnC,CAAN;AACA,cAAM,KAAK1B,WAAL,CAAiBgC,GAAjB,CAAqBN,WAArB,EAAkCO,KAAKC,SAAL,CAAeZ,WAAf,CAAlC,EAA+DE,QAA/D,CAAN;;AAEAF,oBAAYa,SAAZ,GAAwB,SAAxB;AACAb,oBAAYI,WAAZ,GAA0BA,WAA1B;AACA,cAAMU,eAAeT,uBAAIC,IAAJ,CAAS;AAC1BC,kBAAMP;AADoB,SAAT,EAElB,KAAKxB,MAAL,CAAY2B,GAAZ,CAAgB,SAAhB,CAFkB,CAArB;;AAIA,eAAO,EAAEC,WAAF,EAAeU,YAAf,EAA6BZ,QAA7B,EAAP;AACH;;AAED;;;;;AAKA,UAAMO,qBAAN,CAA4BvC,MAA5B,EAAoCkC,WAApC,EAAiD;AAC7C,eAAO,MAAM,KAAK1B,WAAL,CAAiBqC,KAAjB,CAAuB/C,gBAAgBK,kBAAhB,CAAmCH,MAAnC,CAAvB,EAAmE,CAACkC,WAAD,CAAnE,CAAb;AACH;;AAED;;;;;AAKA,UAAMY,0BAAN,CAAiC9C,MAAjC,EAAyCkC,WAAzC,EAAsD;AAClD,eAAO,KAAK1B,WAAL,CAAiBuC,IAAjB,CAAsBjD,gBAAgBK,kBAAhB,CAAmCH,MAAnC,CAAtB,EAAkE,CAAlE,EAAqEkC,WAArE,CAAP;AACH;;AAED;;;;AAIA,UAAMc,WAAN,CAAkBd,WAAlB,EAA+B;AAC3B;;;AAGA,cAAMe,gBAAgBR,KAAKS,KAAL,EAAW,MAAM,KAAK1C,WAAL,CAAiByB,GAAjB,CAAqBC,WAArB,CAAjB,EAAtB;;AAEA,YAAI,CAACe,aAAL,EAAoB;AAChB,mBAAO,IAAP;AACH;;AAED,eAAOA,aAAP;AACH;;AAED;;;;;AAKA,UAAME,OAAN,CAAcC,OAAd,EAAuBlB,WAAvB,EAAoC;AAChC,cAAM,KAAKY,0BAAL,CAAgCM,OAAhC,EAAyClB,WAAzC,CAAN;AACA,cAAM,KAAK1B,WAAL,CAAiBQ,GAAjB,CAAqBkB,WAArB,CAAN;AACH;;AAED;;;;AAIA,UAAMmB,OAAN,CAAcT,YAAd,EAA4B;AACxB,cAAMU,gBAAgB,KAAKC,WAAL,CAAiBX,YAAjB,CAAtB;AACA,cAAM,KAAKnC,YAAL,CAAkB+C,mBAAlB,CAAsCF,cAAcjB,IAAd,CAAmBrC,MAAzD,CAAN;AACA,cAAM,KAAKmD,OAAL,CAAaG,cAAcjB,IAAd,CAAmBrC,MAAhC,EAAwCsD,cAAcjB,IAAd,CAAmBH,WAA3D,CAAN;AACA,eAAO,KAAKd,MAAL,CAAYkC,cAAcjB,IAAd,CAAmBrC,MAA/B,EAAuC,EAAEsB,MAAMgC,cAAcjB,IAAd,CAAmBf,IAA3B,EAAiCG,MAAM6B,cAAcjB,IAAd,CAAmBZ,IAA1D,EAAvC,CAAP;AACH;;AAED;;;;;AAKA8B,gBAAYxC,KAAZ,EAAmB;AACf,YAAI;AACA,mBAAOoB,uBAAIsB,MAAJ,CAAW1C,KAAX,EAAkB,KAAKT,MAAL,CAAY2B,GAAZ,CAAgB,SAAhB,CAAlB,CAAP;AACH,SAFD,CAEE,OAAOyB,CAAP,EAAU;AACR,kBAAM,IAAIC,wBAAJ,CAAuB,cAAvB,CAAN;AACH;AACJ;AA1JgC;kBAAhB7D,e","file":"SessionsService.js","sourcesContent":["import JWT from 'jsonwebtoken';\nimport uuid from 'uuid';\n\nimport { ObjectKeyComposer } from './../../helpers/ObjectKeyComposer';\nimport { SessionType } from '../../resources/sessions/SessionType';\nimport { UnprocessableError } from '../../utils/http';\n/**\n * @typedef {Object} SessionOptions\n * @property {number} lifeTime (seconds)\n * @property {SessionType} type\n */\n\n/**\n * @typedef {Object} CachedSession\n * @property {string} sessionId\n * @property {string} type\n * @property {number} userId\n */\n\n/**\n * @typedef {Object} FullSession\n * @property {number} sessionId\n * @property {number} userId\n * @property {number} lifeTime (seconds)\n * @property {string} accessToken,\n * @property {string} refreshToken\n */\n\nexport default class SessionsService {\n\n    /**\n     * @param {number} userId\n     * @return {string}\n     */\n    static getUserAppendix(userId) {\n        return ObjectKeyComposer.createKey('user', userId);\n    }\n\n    /**\n     * @param {number} userId\n     * @return {string}\n     */\n    static getSessionAppendix(userId) {\n        return ObjectKeyComposer.createKey('user_session', userId);\n    }\n\n    /**\n     * @param {Object} container\n     */\n    constructor({ RedisWrapper, config, UsersService }) {\n        /**\n         * @type {RedisWrapper}\n         * @private\n         */\n        this.redisClient = RedisWrapper;\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this.config = config;\n\n        this.usersService = UsersService;\n    }\n\n    /**\n     * @param {number} userId\n     * @return {Promise<void>}\n     */\n    async destroyAllSessions(userId) {\n        const sessionKey = SessionsService.getSessionAppendix(userId);\n        const existAccessTokens = await this.redisClient.lrange(sessionKey, 0, -1);\n        existAccessTokens.forEach( token => this.redisClient.del(token));\n        const keys = existAccessTokens.concat(sessionKey);\n        await this.redisClient.del(keys.toString());\n    }\n\n    /**\n     * @param {number} userId\n     * @param {object} sessionOptions\n     * @return {Promise<SessionDto>}\n     */\n    async create(userId, sessionOptions = { type: SessionType.User, role: undefined }) {\n        const uniqueKey = uuid.v4();\n\n        /**\n         * @type {CachedSession}\n         */\n        const tokenParams = {\n            userId,\n            type: sessionOptions.type,\n            role: sessionOptions.role,\n            sessionId: uniqueKey\n        };\n\n        const lifeTime = sessionOptions.lifeTime || this.config.get('jwt.lifeTime');\n\n        const accessToken = JWT.sign({\n            data: tokenParams\n        }, this.config.get('jwt.key'), {\n            expiresIn: lifeTime,\n        });\n\n        await this.addTokenToSessionList(userId, accessToken);\n        await this.redisClient.set(accessToken, JSON.stringify(tokenParams), lifeTime);\n\n        tokenParams.tokenType = 'refresh';\n        tokenParams.accessToken = accessToken;\n        const refreshToken = JWT.sign({\n            data: tokenParams\n        }, this.config.get('jwt.key'));\n\n        return { accessToken, refreshToken, lifeTime };\n    }\n\n    /**\n     * @param {number} userId\n     * @param {string} accessToken\n     * @returns {Promise<string[]>}\n     */\n    async addTokenToSessionList(userId, accessToken) {\n        return await this.redisClient.lpush(SessionsService.getSessionAppendix(userId), [accessToken]);\n    }\n\n    /**\n     * @param {number} userId\n     * @param {string} accessToken\n     * @returns {Promise<string[]>}\n     */\n    async deleteTokenFromSessionList(userId, accessToken) {\n        return this.redisClient.lrem(SessionsService.getSessionAppendix(userId), 0, accessToken);\n    }\n\n    /**\n     * @param {string} accessToken\n     * @return {Promise<CachedSession>}\n     */\n    async findSession(accessToken) {\n        /**\n         * @type {CachedSession}\n         */\n        const cachedSession = JSON.parse(await this.redisClient.get(accessToken));\n\n        if (!cachedSession) {\n            return null;\n        }\n\n        return cachedSession;\n    }\n\n    /**\n     * @param {number} adminId\n     * @param {string} accessToken\n     * @return {Promise<void>}\n     */\n    async destroy(adminId, accessToken) {\n        await this.deleteTokenFromSessionList(adminId, accessToken);\n        await this.redisClient.del(accessToken);\n    }\n\n    /**\n     * @param {string} refreshToken\n     * @return {Promise<CachedSession>}\n     */\n    async refresh(refreshToken) {\n        const sessionParams = this.verifyToken(refreshToken);\n        await this.usersService.checkUserForRefresh(sessionParams.data.userId);\n        await this.destroy(sessionParams.data.userId, sessionParams.data.accessToken);\n        return this.create(sessionParams.data.userId, { type: sessionParams.data.type, role: sessionParams.data.role });\n    }\n\n    /**\n     * verify token\n     * @param token\n     * @returns {Object | Error}\n     */\n    verifyToken(token) {\n        try {\n            return JWT.verify(token, this.config.get('jwt.key'));\n        } catch (e) {\n            throw new UnprocessableError('LINK_EXPIRED');\n        }\n    }\n}\n"]}