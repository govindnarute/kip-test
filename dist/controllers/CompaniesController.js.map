{"version":3,"sources":["../../src/controllers/CompaniesController.js"],"names":["CompaniesController","constructor","UserCompaniesService","DBConnection","UserSchoolsService","dbConnection","Industry","model","Function","Company","Location","userCompaniesService","userSchoolsService","createCompanies","request","body","fromDate","toDate","BadRequestError","companies","industriesIds","industries","map","item","id","functionsIds","functions","industriesCount","countByIds","length","NotFoundError","functionsCount","existingCompanies","filter","company","companiesIds","Array","from","Set","companiesCount","existingLocations","location","locationsIds","locationsCount","newCompanies","isArray","savedData","index","value","entries","getOrSaveAutocompleteData","name","concat","Date","deleteUserProfessionalByUserId","user","userId","userProfessional","saveUserProfessional","yearOfExperience","bulkCreateProfessionalIndustry","bulkCreateProfessionalFunction","bulkCreateProfessionalCompany","userCompany","getUserProfessionalFullData","UserProfessionalDto"],"mappings":";;;;;;AAAA;;AACA;;AAEe,MAAMA,mBAAN,CAA0B;AACrCC,gBAAY,EAAEC,oBAAF,EAAwBC,YAAxB,EAAsCC,kBAAtC,EAAZ,EAAwE;AACpE,aAAKC,YAAL,GAAoBF,YAApB;AACA,aAAKG,QAAL,GAAgBH,aAAaI,KAAb,CAAmB,UAAnB,CAAhB;AACA,aAAKC,QAAL,GAAgBL,aAAaI,KAAb,CAAmB,UAAnB,CAAhB;AACA,aAAKE,OAAL,GAAeN,aAAaI,KAAb,CAAmB,SAAnB,CAAf;AACA,aAAKG,QAAL,GAAgBP,aAAaI,KAAb,CAAmB,UAAnB,CAAhB;;AAEA,aAAKI,oBAAL,GAA4BT,oBAA5B;AACA,aAAKU,kBAAL,GAA0BR,kBAA1B;AACH;;AAED,UAAMS,eAAN,CAAsBC,OAAtB,EAA+B;AAC3B,YAAIA,QAAQC,IAAR,CAAaC,QAAb,IAAyBF,QAAQC,IAAR,CAAaE,MAAtC,IAAgDH,QAAQC,IAAR,CAAaC,QAAb,GAAwBF,QAAQC,IAAR,CAAaE,MAAzF,EAAiG;AAC7F,kBAAM,IAAIC,qBAAJ,CAAoB,+CAApB,CAAN;AACH;;AAED,YAAIC,YAAY,EAAhB;AACA,cAAMC,gBAAgBN,QAAQC,IAAR,CAAaM,UAAb,CAAwBC,GAAxB,CAA4BC,QAAQA,KAAKC,EAAzC,CAAtB;AACA,cAAMC,eAAeX,QAAQC,IAAR,CAAaW,SAAb,CAAuBJ,GAAvB,CAA2BC,QAAQA,KAAKC,EAAxC,CAArB;;AAEA;;;AAGA,cAAMG,kBAAkB,MAAM,KAAKhB,oBAAL,CAA0BiB,UAA1B,CAAqC,KAAKtB,QAA1C,EAAoDc,aAApD,CAA9B;AACA,YAAIO,oBAAoBP,cAAcS,MAAtC,EAA8C;AAC1C,kBAAM,IAAIC,mBAAJ,CAAkB,oBAAlB,CAAN;AACH;;AAED,cAAMC,iBAAiB,MAAM,KAAKpB,oBAAL,CAA0BiB,UAA1B,CAAqC,KAAKpB,QAA1C,EAAoDiB,YAApD,CAA7B;AACA,YAAIM,mBAAmBN,aAAaI,MAApC,EAA4C;AACxC,kBAAM,IAAIC,mBAAJ,CAAkB,oBAAlB,CAAN;AACH;;AAED,cAAME,oBAAoBlB,QAAQC,IAAR,CAAaI,SAAb,CAAuBc,MAAvB,CAA8BV,QAAQA,KAAKW,OAAL,CAAaV,EAAnD,CAA1B;AACA,YAAIQ,kBAAkBH,MAAtB,EAA8B;AAC1B,gBAAIM,eAAeH,kBAAkBV,GAAlB,CAAsBC,QAAQA,KAAKW,OAAL,CAAaV,EAA3C,CAAnB;AACAW,2BAAeC,MAAMC,IAAN,CAAW,IAAIC,GAAJ,CAAQH,YAAR,CAAX,CAAf;;AAEA,kBAAMI,iBAAiB,MAAM,KAAK5B,oBAAL,CAA0BiB,UAA1B,CAAqC,KAAKnB,OAA1C,EAAmD0B,YAAnD,CAA7B;;AAEA,gBAAII,mBAAmBJ,aAAaN,MAApC,EAA4C;AACxC,sBAAM,IAAIC,mBAAJ,CAAkB,mBAAlB,CAAN;AACH;;AAEDX,wBAAYa,iBAAZ;AACH;;AAED,cAAMQ,oBAAoB1B,QAAQC,IAAR,CAAaI,SAAb,CAAuBc,MAAvB,CAA8BV,QAAQA,KAAKkB,QAA3C,CAA1B;AACA,YAAID,kBAAkBX,MAAtB,EAA8B;AAC1B,gBAAIa,eAAeF,kBAAkBlB,GAAlB,CAAsBC,QAAQA,KAAKkB,QAAL,CAAcjB,EAA5C,CAAnB;AACAkB,2BAAeN,MAAMC,IAAN,CAAW,IAAIC,GAAJ,CAAQI,YAAR,CAAX,CAAf;;AAEA,kBAAMC,iBAAiB,MAAM,KAAKhC,oBAAL,CAA0BiB,UAA1B,CAAqC,KAAKlB,QAA1C,EAAoDgC,YAApD,CAA7B;;AAEA,gBAAIC,mBAAmBD,aAAab,MAApC,EAA4C;AACxC,sBAAM,IAAIC,mBAAJ,CAAkB,oBAAlB,CAAN;AACH;AACJ;;AAED;;;;;AAKA,cAAMc,eAAe9B,QAAQC,IAAR,CAAaI,SAAb,CAAuBc,MAAvB,CAA8BV,QAAQ,CAACA,KAAKW,OAAL,CAAaV,EAApD,CAArB;AACA,YAAIY,MAAMS,OAAN,CAAcD,YAAd,KAA+BA,aAAaf,MAAhD,EAAwD;AACpD,gBAAIiB,SAAJ;;AAEA;AACA,iBAAK,MAAM,CAACC,KAAD,EAAQC,KAAR,CAAX,IAA6BJ,aAAaK,OAAb,EAA7B,EAAqD;AACjDH,4BAAY,MAAM,KAAKlC,kBAAL,CAAwBsC,yBAAxB,CAAkD,KAAKzC,OAAvD,EAAgEuC,MAAMd,OAAN,CAAciB,IAA9E,CAAlB;AACAP,6BAAaG,KAAb,EAAoBb,OAApB,CAA4BV,EAA5B,GAAiCsB,UAAUtB,EAA3C;AACH;;AAEDL,wBAAYa,kBAAkBoB,MAAlB,CAAyBR,YAAzB,CAAZ;AACH;;AAED;AACAzB,oBAAYA,UAAUG,GAAV,CAAeC,IAAD,IAAU;AAChCA,iBAAKP,QAAL,GAAgBO,KAAKP,QAAL,GAAiB,GAAEO,KAAKP,QAAS,QAAjC,GAA2C,IAAIqC,IAAJ,EAA3D;AACA9B,iBAAKN,MAAL,GAAcM,KAAKN,MAAL,GAAe,GAAEM,KAAKN,MAAO,QAA7B,GAAuC,IAAIoC,IAAJ,EAArD;;AAEA,mBAAO9B,IAAP;AACH,SALW,CAAZ;;AAOA,cAAM,KAAKZ,oBAAL,CAA0B2C,8BAA1B,CAAyDxC,QAAQyC,IAAR,CAAaC,MAAtE,CAAN;AACA;AACA,cAAMC,mBAAmB,MAAM,KAAK9C,oBAAL,CAA0B+C,oBAA1B,CAA+C5C,QAAQyC,IAAR,CAAaC,MAA5D,EAAoE1C,QAAQC,IAAR,CAAa4C,gBAAjF,CAA/B;;AAEA,cAAM,KAAKhD,oBAAL,CAA0BiD,8BAA1B,CAAyD9C,QAAQC,IAAR,CAAaM,UAAtE,EAAkFoC,iBAAiBjC,EAAnG,CAAN;AACA,cAAM,KAAKb,oBAAL,CAA0BkD,8BAA1B,CAAyD/C,QAAQC,IAAR,CAAaW,SAAtE,EAAiF+B,iBAAiBjC,EAAlG,CAAN;AACA,cAAM,KAAKb,oBAAL,CAA0BmD,6BAA1B,CAAwD3C,SAAxD,EAAmEsC,iBAAiBjC,EAApF,CAAN;;AAEA,cAAMuC,cAAc,MAAM,KAAKpD,oBAAL,CAA0BqD,2BAA1B,CAAsDlD,QAAQyC,IAAR,CAAaC,MAAnE,CAA1B;;AAEA,eAAO,IAAIS,sCAAJ,CAAwBF,WAAxB,CAAP;AACH;AAjGoC;kBAApB/D,mB","file":"CompaniesController.js","sourcesContent":["import { NotFoundError, BadRequestError } from '../utils/http';\nimport { UserProfessionalDto } from '../models/userProfessionals';\n\nexport default class CompaniesController {\n    constructor({ UserCompaniesService, DBConnection, UserSchoolsService }) {\n        this.dbConnection = DBConnection;\n        this.Industry = DBConnection.model('Industry');\n        this.Function = DBConnection.model('Function');\n        this.Company = DBConnection.model('Company');\n        this.Location = DBConnection.model('Location');\n\n        this.userCompaniesService = UserCompaniesService;\n        this.userSchoolsService = UserSchoolsService;\n    }\n\n    async createCompanies(request) {\n        if (request.body.fromDate && request.body.toDate && request.body.fromDate > request.body.toDate) {\n            throw new BadRequestError('toDate must be greater or equal than fromDate');\n        }\n\n        let companies = [];\n        const industriesIds = request.body.industries.map(item => item.id);\n        const functionsIds = request.body.functions.map(item => item.id);\n\n        /**\n         * Count by Ids and compare with requested elements\n         */\n        const industriesCount = await this.userCompaniesService.countByIds(this.Industry, industriesIds);\n        if (industriesCount !== industriesIds.length) {\n            throw new NotFoundError('INDUSTRY_NOT_FOUND');\n        }\n\n        const functionsCount = await this.userCompaniesService.countByIds(this.Function, functionsIds);\n        if (functionsCount !== functionsIds.length) {\n            throw new NotFoundError('FUNCTION_NOT_FOUND');\n        }\n\n        const existingCompanies = request.body.companies.filter(item => item.company.id);\n        if (existingCompanies.length) {\n            let companiesIds = existingCompanies.map(item => item.company.id);\n            companiesIds = Array.from(new Set(companiesIds));\n\n            const companiesCount = await this.userCompaniesService.countByIds(this.Company, companiesIds);\n\n            if (companiesCount !== companiesIds.length) {\n                throw new NotFoundError('COMPANY_NOT_FOUND');\n            }\n\n            companies = existingCompanies;\n        }\n\n        const existingLocations = request.body.companies.filter(item => item.location);\n        if (existingLocations.length) {\n            let locationsIds = existingLocations.map(item => item.location.id);\n            locationsIds = Array.from(new Set(locationsIds));\n\n            const locationsCount = await this.userCompaniesService.countByIds(this.Location, locationsIds);\n\n            if (locationsCount !== locationsIds.length) {\n                throw new NotFoundError('LOCATION_NOT_FOUND');\n            }\n        }\n\n        /**\n         * Check new company exists.\n         * Save company with bulk create\n         * Map saved companies and push to already existing company array (check by name, because name is unique)\n         */\n        const newCompanies = request.body.companies.filter(item => !item.company.id);\n        if (Array.isArray(newCompanies) && newCompanies.length) {\n            let savedData;\n\n            // Check all nullable field and save new autocomplete data\n            for (const [index, value] of newCompanies.entries()) {\n                savedData = await this.userSchoolsService.getOrSaveAutocompleteData(this.Company, value.company.name);\n                newCompanies[index].company.id = savedData.id;\n            }\n\n            companies = existingCompanies.concat(newCompanies);\n        }\n\n        // TODO: Make valid date for saving to DB (client send only year)\n        companies = companies.map((item) => {\n            item.fromDate = item.fromDate ? `${item.fromDate}-01-01` : new Date();\n            item.toDate = item.toDate ? `${item.toDate}-01-01` : new Date();\n\n            return item;\n        });\n\n        await this.userCompaniesService.deleteUserProfessionalByUserId(request.user.userId);\n        // Save all professional data\n        const userProfessional = await this.userCompaniesService.saveUserProfessional(request.user.userId, request.body.yearOfExperience);\n\n        await this.userCompaniesService.bulkCreateProfessionalIndustry(request.body.industries, userProfessional.id);\n        await this.userCompaniesService.bulkCreateProfessionalFunction(request.body.functions, userProfessional.id);\n        await this.userCompaniesService.bulkCreateProfessionalCompany(companies, userProfessional.id);\n\n        const userCompany = await this.userCompaniesService.getUserProfessionalFullData(request.user.userId);\n\n        return new UserProfessionalDto(userCompany);\n    }\n}\n"]}