{"version":3,"sources":["../../src/controllers/VerificationsController.js"],"names":["VerificationsController","constructor","SessionsService","MailerService","VerificationsService","UsersService","sessionsService","mailerService","verificationsService","usersService","verifyUser","request","verificationToken","getTokenByType","body","token","tokenTypes","verification","BadRequestError","isUsed","decoded","verifyToken","user","getUserById","data","userId","UnprocessableError","isVerified","update","EmptyDto","resendVerification","getUserByEmailWithVerificationToken","email","attempt","maxAttempts","isBefore","createdAt","add","isAfter","destroy","generateToken","tokenLifeTime","updateOrCreateToken","sendVerificationEmail","restorePassword","scope","password","NotFoundError","social","sendRestorePasswordEmail","verifyRestorePassword","verifyPasswordToken"],"mappings":"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","file":"VerificationsController.js","sourcesContent":["import { BadRequestError, UnprocessableError, NotFoundError } from '../utils/http';\nimport { EmptyDto } from '../base/EmptyDto';\nimport { tokenTypes, maxAttempts } from '../resources/users';\nimport moment from 'moment';\n\nexport default class VerificationsController {\n    constructor({ SessionsService, MailerService, VerificationsService, UsersService }) {\n        this.sessionsService = SessionsService;\n        this.mailerService = MailerService;\n        this.verificationsService = VerificationsService;\n        this.usersService = UsersService;\n    }\n\n    /**\n     * Email verification token\n     * @param {e.Request} request\n     * @return {Promise<EmptyDto>}\n     */\n    async verifyUser(request) {\n        const verificationToken = await this.verificationsService.getTokenByType(request.body.token, tokenTypes.verification);\n\n        if(!verificationToken) {\n            throw new BadRequestError('TOKEN_INVALID');\n        }\n\n        if(verificationToken.isUsed) {\n            throw new BadRequestError('TOKEN_USED');\n        }\n\n        const decoded = await this.sessionsService.verifyToken(request.body.token);\n        const user = await this.usersService.getUserById(decoded.data.userId);\n\n        if(!user) {\n            throw new UnprocessableError('USER_NOT_FOUND');\n        }\n\n        if(user.isVerified) {\n            throw new UnprocessableError('ALREADY_VERIFIED', 'ALREADY_VERIFIED');\n        }\n\n        await user.update({ isVerified: true });\n        await verificationToken.update({ isUsed: true });\n\n        return new EmptyDto();\n    }\n\n    /**\n     * Resend verification email\n     * @param {e.Request} request\n     * @return {Promise<EmptyDto>}\n     */\n    async resendVerification(request) {\n        const user = await this.usersService.getUserByEmailWithVerificationToken(request.body.email, tokenTypes.verification);\n\n        if(!user) {\n            throw new BadRequestError('NO_SUCH_EMAIL');\n        }\n\n        if(user.isVerified) {\n            throw new UnprocessableError('ALREADY_VERIFIED');\n        }\n\n        // check if users has attempts left\n        if(user.verificationToken\n            && user.verificationToken.attempt >= maxAttempts\n            && moment().isBefore(moment(user.verificationToken.createdAt).add(24, 'hour'))) {\n            throw new BadRequestError('ATTEMPTS_EXCEEDED');\n        }\n\n        // delete old token and attempt counter after 24 h period if exists\n        if(user.verificationToken && moment().isAfter(moment(user.verificationToken.createdAt).add(24, 'hour'))) {\n            await user.verificationToken.destroy();\n        }\n\n        const token = await this.verificationsService.generateToken(user, request.body.tokenLifeTime);\n        await this.verificationsService.updateOrCreateToken(user, token, tokenTypes.verification);\n\n        this.mailerService.sendVerificationEmail(user, token);\n\n        return new EmptyDto();\n    }\n\n    /**\n     * Send restore password email\n     * @param {e.Request} request\n     * @returns {EmptyDto}\n     */\n    async restorePassword(request) {\n        const scope = ['withSocial'];\n        const user = await this.usersService.getUserByEmailWithVerificationToken(request.body.email, tokenTypes.password, scope);\n\n        if (!user) {\n            throw new NotFoundError('USER_NOT_FOUND');\n        }\n\n        if (user.social) {\n            throw new NotFoundError('CONNECTED_LINKED_IN_ACCOUNT');\n        }\n\n        const token = await this.verificationsService.generateToken(user, request.body.tokenLifeTime);\n        await this.verificationsService.updateOrCreateToken(user, token, tokenTypes.password);\n\n        this.mailerService.sendRestorePasswordEmail(user, token);\n\n        return new EmptyDto();\n    }\n\n    /**\n     * Verify restore password\n     * @param {e.Request} request\n     * @returns {UserDto}\n     */\n    async verifyRestorePassword(request) {\n        const decoded = this.sessionsService.verifyToken(request.body.token);\n\n        const verificationToken = await this.verificationsService.getTokenByType(request.body.token, tokenTypes.password);\n\n        if(!verificationToken) {\n            throw new BadRequestError('TOKEN_INVALID');\n        }\n\n        if(verificationToken.isUsed) {\n            throw new BadRequestError('PASSWORD_RESTORED');\n        }\n\n        const user = await this.usersService.getUserById(decoded.data.userId);\n\n        if(!user) {\n            throw new UnprocessableError('USER_NOT_FOUND');\n        }\n\n        await user.update({ password: request.body.password });\n\n        await verificationToken.update({ isUsed: true });\n        return new EmptyDto();\n    }\n\n    /**\n     * * Verify restore password token\n     * @param {e.Request} request\n     * @return {Promise<EmptyDto>}\n     */\n    async verifyPasswordToken(request) {\n        this.sessionsService.verifyToken(request.body.token);\n\n        const verificationToken = await this.verificationsService.getTokenByType(request.body.token, tokenTypes.password);\n\n        if(!verificationToken) {\n            throw new BadRequestError('TOKEN_INVALID');\n        }\n\n        if(verificationToken.isUsed) {\n            throw new BadRequestError('PASSWORD_RESTORED');\n        }\n\n        return new EmptyDto();\n    }\n}\n"]}